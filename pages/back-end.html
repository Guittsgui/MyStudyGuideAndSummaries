<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Front End.</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>

        <a href="../index.html">Home</a>
        <div class="title">
            <h1>Final Study Resume Guide</h1>
        </div>
        <div class="nav">
            <ul>
                <li><a href="#db"> BancoDados</a></li>
                <li><a href="#pr"> Prisma</a></li>
                <li><a href="#api"> API </a></li>
                <li><a href=""> Middlewares</a></li>
                <li><a href=""> JWT </a></li>
            </ul>
        </div>


    <div class="base">
        <h2 id="node"> Node JS </h2>
        <p> Aqui iremos começar a jornada do <strong>BACKEND</strong>. Indo mais direto ao ponto, de acordo com a arquitetura da programação moderna, na maioria das vezes você irá se deparar com a criação de <strong>APIS</strong>. Apis é um ponto de conexão entre o front e o banco de dados. A API é o <strong>BACKEND</strong> da sua aplicação. Por exemplo, quando voce se cadastra em um site (FrontEnd), e envia a requisição para criar nova conta, essa requisição não vai direto para o banco de dados, ela passa por um "porteiro", que irá validar os dados, confirmar com o banco se os dados já não existem , etc. Esse porteiro é a nossa API, que é o BackEnd. Dito tudo isso, praticamente sempre no mundo real o backend irá se comunicar com um banco de dados, então podemos dar início aos estudos de <strong>BackEnd</strong> através dos Banco de Dados.</p>
        <hr> 
        <h2 id="db"> MySQL </h2>
        <p> Dentro do banco de dados temos basicamente duas coisas que precisamos mexer. O Servidor( Software que é o próprio banco de dados), e o Cliente, que é o software que utiliza o servidor, ou seja, usa o bacno de dados. Por exemplo, ao desenvolvermos uma API que consome um Banco, a API é o cliente e o Banco é o servidor. Primeiramente iremos aprender sobre banco de dados <strong>Relacionais - SQL</strong>. De início começaremos com o <strong>MySQL</strong> ou o <strong>Postgree</strong>. Ambos são open source, ambos funcimam em todos os sistemas operacionais, e ambos também suportam qualquer linguagem de programação. Porém possuem algumas diferenças como o <strong>mysql</strong> NÃO ser casesenstive, já o postgree é casesensitive. Porém e quando falamos de performance? Quando falamos em querys complexas ou grandes volumes, o postgree tende a ser um pouco mais rápido, já quando falamos para pequenos volumes ou consultas simples, o mysql tende a ser mais rápido do que o postgrees. Aqui quando estamos falando de mais rápido ou mais devagar, estamos falando de diferenças de milisegundos. Dito isto, quando esta iniciando, tanto faz a escolha, sem contar que sabendo utilizar um, o outro é praticamente tão fácil quanto. </p>
        <p> O primeiro passo para começarmos a colocar a mão na massa é instalarmos o banco de dados que deseja escolher, e em seguida instalhar um <strong>cliente sql</strong> que é basicamente um software que nos permite interagir com o banco de dados em questão, executar querys, comando, etc. Particularmente eu costumo utilizar o <strong>MySQLWorkBench</strong>, que dependendo da configuração do dispositivo do usuário pode não ser a melhor escolha por acabar sendo um pouco 'pesado', porém temos opções como Dbeaver, etc.</p><br>
        <h3> ORMS </h3>
        <p> Agora que já entendemos o que são os banco de dados, seus tipos e seus clientes, precisamos entender outro fator fundamental para a integração deles com nossa aplicação(NodeJS), que são as <strong>ORMS</strong>. Existem várias formas de conectarmos os bancos de dados com nossos códigos, e uma dessas formas é o bom e velho ORM. ORM -> Object Relational Mapper, que traduzindo seria o mapeamento de um objeto-relacional. Basicamente instalamos bibliotecas em nosso sistema e criamos entre aspas uma cópia do banco de dados dentro do nosso código. Por exemplo, "O banco se chamará tal, teremos tais tabelas, cada tabela armazena tais atributos, seus tipos etc'. Mas, se já temos isso dito no banco, para que precisamos repetir no código ? Precisamos repetir no código para que ele entenda exatamente todo o comportamento do banco, desas forma, podemos dentro do código adicionar um usuário por exemplo ao banco de forma extremamente simples como : users.add(user), ao invés de termos que digitar querys longas, etc. Agora que já entendemos o que são as ORM's, estudaremos duas: <strong> Prima & Sequelize</strong>. </p><br>
        <h3 id="pr"> Prisma </h3><br>
        <p> Prisma foi feito exatamente para funcionar com o Node + Typescript. Basicamente no código criamos tudo em um só lugar. No código criamos como o banco irá ficar, que irá gerar um type, que irá criar a estrutura no banco de dados, tudo alinhado e padronizado. </p><p> O primeiro passo é criarmos nosso projeto e instalarmos a biblioteca do prisma. Para criarmos nosso projeto, poderemos utilizar um repositório que nos fornece uma pré configuração de um servidor. <a href="https://github.com/suporteb7web/node-api-base" target="_blank">NODE-API-BASE</a>. Após criado a base, precisamos instalar o Prisma em nosso projeto, com o comando: <strong>npm i -D prisma </strong>, que já vem por padrão com suporte a TypeScript. Uma das caracteristicas do Prisma é que ele trabalha com o conceito de CLI (linha de comandos no terminal).  O primeiro comando que precisamos entender é o seguinte: </p><br>
        <p> <strong>INICIAR O PRISMA: NPX PRISMA INIT </strong></p><br>
        <p> Após Criado, ele irá criar seu próprio .ENV, porém como já possuímos o nosso, basta copiar o que está la dentro, e colocar para dentro do nosso próprio env.local. Uma vez que o prisma estiver iniciado, ele já fará toda a configuração inicial, e a primeira que precisamos nos atentar, é a variavel de ambiente que copiamos. Por padrão ele vem configurado para trabalhar com POSTGREE, porém caso queiramos trocar para mysql, basta alterar ali. Ali também encontramos informacoes chave como o usuário, senha, porta e nome do banco. A única coisa que o prisma não faz é criar o próprio banco em si, isso precisaremos fazer na mão, mas o resto todo ele irá fazer por conta própria. </p>
        <p> Podemos reparar que ao instalarmos o prisma, uma pasta PRISMA foi criada, logo, o próximo passo é entendermos o que há dentro dela. Ali iremos ver que temos um <strong>schema.prisma</strong> local onde iremos realizar grande parte de nossas configurações. Vale ressaltar que tabelas no Prisma são chamadas de <strong>Model</strong>. Ali dentro teremos o <strong>generator client & datasource DB</strong>. Abaixo deles, começaremos a construir o nosso Banco.  </p>
        <img src="../backPhotos/b1.png" alt="">
        <p> O prisma possui um recurso extremamente bacana que é o <strong>PUS & PULL</strong>. Funciona mais ou menos igual no git, quando damos um git push, pegamos o código e enviamos para o repositório remoto. Quando damos um git pull, pegamos o repositório remoto e juntamos com o código. No caso do prisma ele tem o mesmo princípio. Através do <strong> push </strong> e irá enviar para o banco tudo o que configuramos em seu arquivo acima. E caso tenhamos um banco criado e queiramos pegar o banco de dados e com base nele criar um schema, podemos usar o <strong> pull </strong>. Comandos: </p><br>
        <p> <strong> ENVIAR P/ BANCO: NPX PRISMA DB PUSH</strong></p>
        <p> <strong> PUXAR DO BANCO: NPX PRISMA DB PULL </strong></p><br>
        <h3> Migrations </h3>
        <p> Esse conceito não é exclusivo do Prisma, e sim da programação em geral. São basicamente um histórico de modificação na estrutura do banco de dados. Funciona basicamente igual um Commit, criando um histórico do banco de dados. Mas para que precisamos disso ? Primeramente sempre saberemos a evolucao do banco, e também para conseguir reverter modificações. Por ex: Adicionamos um novo campo na tabela usuário, um novo campo na tabela tarefas. Caso algo de errado nessas novas features, poderemos facilmente reverter e voltar pro estado anterior. Veremos o comando das migrations: <small>Quando criamos migraitons, automaticamente ele da o Push.</small> </p><br>
        <p><strong> CRIANDO MIGRATIONS: NPX PRISMA MIGRATE DEV </strong></p><br>
        <h3> Relações/FK</h3>
        <p> Comumente dentro de nossas aplicações iremos trabalhar com entidades que possuem relações com outras entidades. Por exemplo, uma tabela de Usuários e uma tabela de Posts. Existe uma ligação entre elas, afinal, um usuário pode ter um ou muitos Posts. Para isso, basta por exemplo colocarmos dentro da tabela post, o campo UserID. Pronto, dessa forma eles passarão a ser interligados, e podemos gerenciar tudo pelo próprio código. Porém, imagine a situação em que um usuário resolve excluir sua conta. Se essa relação for feita apenas via código, iremos ter no banco de dados diversos registros de Posts de um usuário inexistente por exemplo. Por isso, é importante fazermos o relacionamento também no banco. E o Prisma nos possibilita isso, como no exemplo abaixo:  </p>
        <img src="../backPhotos/b2.png" alt="">
        <h3> Propriedades e ENUMS: </h3>
        <p> Aqui iremos dar uma visualizada nos tipos de dados e opções que temos para trabalhar dentro do Prisma. </p>
        <img src="../backPhotos/b3.png" alt="">
        <h3> Usando o MAPPING: </h3>
        <p> Mapping nao tem nenhuma aplicação prática em termos de recursos no código. Porém ele é importante no sentido de organização no código. É mais utilizado quando temos nomes diferentes entre o schema e a tabela em si do banco. Ou então quando temos por exemplo no schemna "subtitle" e no banco precisamos salvar "sub_title". Dessa forma através do <strong>mapping</strong> conseguimos realizar essas trocas. Exemplo abaixo: </p>
        <img src="../backPhotos/b4.png" alt="">
        <h3> Prisma Studio </h3>
        <p> É uma ferramenta do próprio prisma que funciona basicamente como um dbiever ou workbench, e nos apresentar através de um sistema próprio, da nossa própria estrutura do schema.prisma. Para isso precisamos digitar o comando: </p><br>
        <p> <strong> ABRIR PRISMA STUDIO: NPX PRISMA STUDIO</strong></p><br>
        <h3> Prisma Client</h3>
        <p> Como vimos anteriormente, ao darmos um prima init ele automaticamente cria um arquivo, que possui dois objetos, o de configuracao do banco, e o prisma client. E aqui iremos aprender sobre o prisma cliente, qeu será fortemente utilizado a patir de então. A partir daqui aprenderemos a utilizar o prisma no mundo real. Para isso, precisamos começar entendendo o que ele faz e como ele funciona. O <strong>prisma client</strong> nada mais é do que uma biblioteca que é criada/gerada no ato. Ela é criada conforme nosso código de configuração do Prisma. Após criarmos nossos schemas, com base nisso o prisma irá gerar para gente basicamente duas coisas distintas: Os types do Typescript exatamente igual nossos schemas. E o outro recurso, é o das relações por debaixo dos panos. Como por exemplo quando falamos user e posts, através do prisma client, podemos puxar por ex um post e as informacoes do usuário tudo de uma única vez. </p>
        <p> Dito isto, como o prisma client é gerado baseado em nosso código, sempre que alterarmos o código precisamos automáticamente gerar outro prisma client. Porém, em muitos comandos que utilizamos como por exemplo as <strong>migrations</strong> ele já atualiza o PC automáticamente. </p>
        <p> Dito isto, a partir daqui podemos definitivamente integrar o prisma ao projeto. É importante e ideal é que separemos o prisma client da aplicação. Para isso podemos criar uma pasta chamada <strong>Libs</strong> e dentro um arquivo chamado <strong>prisma.ts</strong> . Dentro desse prisma.ts , instanciaremos o prisma client, e em seguida iremos exportar essa instância, instancia essa na qual pode ser chamada de prisma ou de DB. A partir dessa instancia em qualquer lugar dentro da nossa aplicação podemos acessar o banco, através dessa instancia. Um problema muito comum de usuários de prisma é um error no banco de dados, informando que existem multiplas conexões no banco de dados, etc. Ao lermos a documentação ela explica o motivo e também a solução. É muito comum que em nossos projetos utilizemos o <strong>watch</strong>, nodemmon, etc, que nada mais é do que um recurso de monitoramento de qualquer mudança realizada na aplicação. Dessa forma, sempre que alteramos e voltamos, ele irá recarregar o código todo, logo, irá gerar uma nova instancia do prisma client, e assim uma nova conexão. Este é o <strong>Motivo do Erro</strong>, e lendo a documentação ela nos diz que precisamos copiar um trecho de código e colar em nosso prisma client. Dessa forma essa "duplicação" não irá mais acontecer. Link da documentação <a href="https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections" target="_blank">Clicando Aqui</a></p>
        <img src="../backPhotos/b5.png" alt=""><br>
        <h3> Watch & Imsonia </h3>
        <p> Antes de fato de colocarmos a mão no ORM dentro do projeto, precisamos habilitar o Watch. para isso, utilizamos o comando:  </p><br>
        <p><strong> Habilitar o Watch:  npm i -D tsx </strong></p><br>
        <p> Agora que ja temos a dependencia watch instalada, precisamos ir dentro do arquivo <strong>package.json</strong>  e alterar o "script", como o da imagem, a partir daqui, qualquer alteração que realizarmos dentro do nosso código, será monitorado e o servidor rodará novamente. </p>
        <img src="../backPhotos/b6.png" alt=""><br>
        <h3> CRUD - CREATE </h3>
        <p> Aqui iremos aprender a inserir um nobo registro na tabela. Da forma mais simples que temos, adicionamos um novo registro assim: </p>
        <img src="../backPhotos/b7.png" alt="">
        <p> <strong> OBS: </strong> Temos sempre que lembrar que a comunicação entre a API e o BANCO é uma comunicação assíncrona e do meio externo, logo, caso aconteça algum error nesse percurso, precisamos trata-los e informar aos demais. Quando falamos em tratar error, uma das primeiros coisas que lembramos é do <strong>try/catch</strong>. Abaixo um exemplo do error sendo tratado no trycatch: </p>
        <img src="../backPhotos/b8.png" alt="">
        <h2> Usando os Types do Prisma</h2>
        <p> O prisma já nos permite utilizar um type pré criados para isso. Por exemplo, podemos tipar as props de um método no service utilizando um Type fornecido pelo próprio prisma, fazendo com que a confiabilidade fique exatamente igual e de acordo com o que possuímos dentro do nosso banco de dados. Exemplo: </p>
        <img src="../backPhotos/b9.png" alt=""><br>
        <p> Outro fator muito interessante no Prisma, é que ele nos permite criar muitos usuários de uma úica vez. Por exemplo, podemos receber por parâmetro um Array de usuários, e em seguida com apenas um comando, adicionar todos os usuários de uma única vez ao banco de dados, e ainda podemos colocar um comando que nos permite pular o duplicado.</p>
        <img src="../backPhotos/b10.png" alt="">
        <hr>
        <h2 id="api"> API </h2>
        <p> Quando comecamos a estudar backend aqui no capitulo de <a href="#node">NodeJS</a> nós já demos uma pincelada sobre o que é uma API, que funciona como um intermediador entre uma aplicacao front e um banco de dados. Quando trabalhamos com WEB, usaremos constantemente os termos <strong> REST </strong> e <strong> RestFull</strong>.Rest, significa Transferencia de estado representacional, basicamente ele é um padrão. Uma api feita no padrão REST é a mesma coisa que falar: esse texto está escrito em portugues. Restfull é um sistema que utiliza um padrão Rest. Logo, se voce desenvolver uma API usando o padrão REST, ela será uma API Restfull.  O padrão REST possui alguns pilares que iremos ver nesse capítulo, como os <strong>EndPoints, Métodos(GET,POST,PUT,DEL)</strong>, entre outros que iremos ver com o tempo. </p>
        <p> Podemos começar então <strong>Criando o Projeto </strong> que pode ser criado do zero como veremos nesse módulo, ou então clonando do github nesse link já pré configurado: <a href="https://github.com/suporteb7web/node-api-base" target="_blank">NODE-API-BASE</a> que irá facilitar o processo inicial, porém é importante saber como começar do zero.</p>
        <p> Para começar do zero, precisamos gerar os seguintes comandos: <strong> npm init</strong> para startar o projeto. Em seguida, instalar as dependencias com o comando: <strong>npm install dotenv express pg pghstore sequelize validator </strong>. Para iniciar o typescript, precisamos roadr o comando: <strong>tsc --init</strong>, e em seguida realizar algumas alterações basicas como colocar para o ecmascript 6, setar a root e a outDir como na imagem abaixo, descomentar o moduleresolution: node,  e em seguida criar a pasta SRC, onde ficará concentrado todo o "core" da nossa aplicação. </p>
        <img src="../backPhotos/b11.png" alt="">
        <p> Para finalizar, precisamos instalar os Types da nossa aplicação, com o comando: <strong>npm install --save-dev @types/express @types/node @types/validator  </strong>. Tendo tudo isso configurado, podemos criar e começar a trabalhar com nosso servidor, (dentro da pasta src). </p>
        <img src="../backPhotos/b12.png" alt="">
        <p> Para finalizar a criação inicial do nosso backend, precisamos apenas criar dentro do packageJson, no objeto Scripts, o comando para startar o projeto: <strong>"start-dev": "nodemon -e ts,json src/server.ts"</strong>, e agora para startarmos basta irmos até o console e colocar: <strong>npm run start-dev</strong>.</p>
        <p> Agora que temos o "core" da nosas API criada, iremos começar a trabalhar de forma basica nela, e com o tempo separando, colocando casa coisa em seu devido "lugar". Podemos começar criando as nossas <strong>Rotas</strong>. Como já devemos imaginar, onde colocaremos nossas rotas? Exatamente, dentro de uma pasta chamada Rouets. Entao criamos essa pasta, e dentro dela podemos criar um arquivo chamado: Api.TS, onde iremos configurar nossas rotas e seus devidos Endpoints. Tendo o arquivo criado, já podemos começar a construir nossos Endpoints. De início, iremos criar o <strong>Ping/Pong</strong> que é o básico para testarmos se uma API está funcionando. Logo em seguida, precisamos colocar esse arquivo Api.ts dentro do "core" da nossa aplicação para que ele passe a ser visto. </p><br>
        <p><strong> Routes: </strong></p>
        <img src="../backPhotos/b13.png" alt="">
        <p> <strong> Implemento Routes no Core: </strong></p>
        <img src="../backPhotos/b14.png" alt="">
        <p> Muitas vezes parametros serão enviados através do Endpoint, para que possamos pegar dentro das rotas (futuramente dos controllers), para isso, podemos criar rotas dinamicas, da seguinte forma: </p>
        <img src="../backPhotos/b15.png" alt="">
        <h2> Entendendo CORS: </h2>
        <p> Quando estudamos requisições REACT no módulo de frontEnd, vimos sobre CORS, e aqui veremos mais afundo. Quando estamos criando uma API, por padrão ela só irá aceitar requisições do mesmo domínio. Logo, através das <strong>configurações do CORS</strong> podemos configurar exatamente quais domínios podem acessar nossa API, e ainda podemos ser mais específicos, podemos configurar quais métodos podem ser utilizados em cada endpoint da sua api por exemplo. Para resolver esse problema, podemos instalar uma biblioteca chamda CORS. Para isso, utilizamos o comando: <strong>npm install Cors. </strong> e também seus types: <strong>npm install -D @types/cors</strong>. Em seguida, dentro do nosso servidor, podemos importar o cors, e configugrar exatamente como gostariamos de configurar o CORS. </p>
        <img src="../backPhotos/b16.png" alt="">
        <h2> Controllers </h2>
        <p> A partir daqui passaremos a trabalhar com Controllers,entre outras páginas para que possamos separar melhor cada informação. Criamos um Controller para cada entidade da sua aplicação, e ele será o responsável por todos os métodos existentes e responsáveis por ela. Por exemplo, criaremos dentro do controller funcoes para adicionar, remover, etc. E lá nas rotas, ao invés de colocarmos a função diretamente, iremos colocar a função do Controller a ser executada. </p>
        <img src="../backPhotos/b17.png" alt="">
        <img src="../backPhotos/b18.png" alt="">
        <h2> Requisições POST: </h2>
        <p> Quando recebemos requisições post, as informacoes estão no Body (<strong>req.body)</strong></p>
        <img src="../backPhotos/b19.png" alt="">
        <h2> Status Code </h2>
        <p> Quando estamos desenvolvendo API'S padrão REST, outra coisa de fundamental importancia são os status das nossas Responses. Através desses status que os futuros consumidores de nossas API'S irão saber como lidar com os diversos tipos de respostas possíveis. Os statusCode funcionam como " números que indicam o que houve ", como por exemplo : 200 - OK, 201 - OK Adicionado, 400 - Error. etc. Você não precisa decorar exatamente cada variação, apenas a sua faixa, ex: do 0 ao 99 é isso, do 99 ao 199 aquilo, e por ai vai. </p><br>
        <h2> Autenticacao vs Autorizacao </h2>
        <p> Constantemente ao desenvolvermos aplicações iremos nos deparar com a necessidade de realizar logins, criar contas, etc. Para que isso ocorra, precisamos ter claro na mente a diferenca de Autorizacao e Autenticacao. Autorizacao, é simplesmente quando uma pessoa PODE ou NÃO pode realizar determinada tarefa. Ela não está ligada a QUEM, e sim a se pode ou não. Já a AUTENTICAÇÃO, é o processo de saber quem é o usuário que está tentando realizar tal tarefa. Na autorizacao é quando descobrimos quem é voce, e na autorizacao é se voce pode ou não realizar determinada tarefa. Agora que já entendemos a diferença entre elas, iremos nos aprofundar previamente sobre os <strong>Tipos de Autenticações</strong> que podemos vir a trabalhar. <strong>Single-Factor Auth</strong> É basicamente a de um fator, uma única etapa, ou seja, colocamos usuário e senha por exemplo, e baseado nisso o sistema lhe dá ou não o acesso. Outro tipo que vem ganhando cada vez mais espaço é a <strong>Two-Factor Authentication</strong> que é a autenticação em dois fatores, que também é conhecido como <strong>2FA</strong>, que basicamente precisamos acertar o usuário e senha, e em seguida precisamos realizar uma segunda etapa, para confirmarmos ainda mais que somos nós mesmos. Também existe o <strong>Multi-Factor Authentication (MFA) </strong>, é uma autenticacão em múltiplos fatores, onde o usuário para logar precisa enfrentar várias etapas. Outro bastante utilizado nos dias atuais e o <strong>Single Sign-On (SSO)</strong>, que seria uma "Autenticação única universal". Muito comum com sua conta do gmail por exemplo, que ao voce logar, voce automaticamente irá logar no youtube também. Ou na Meta, quando voce loga no FB, já efetua o login no Instagram também. Essas são básicamente as formas que temos de autenticar. </p>
        <p> Agora mergulheremos um pouco mais nos termos técnicos, pois independente de qual tipo de autenticação utilizar, temos um próximo passo, que é a forma de como iremos liberar o acesso após o usuario ser autenticado. E para isso existem também algumas formas que veremos aqui. <strong>Basic Auth</strong> É uma forma de em todas as requisições que tivermos dentro da aplicação iremos enviar junto o seu usuário e senha, para que possamos veririficar. Isso acontece utilizando um Hash chamado e <strong> BASE64</strong>. Apesar de já ter sido uma das formas mais utilizadas, nos dias atuais praticamente não é mais. Atualmente utilizamos as chamadas <strong> OAUTH (1 & 2)</strong>. O OAuth 1, basicamente utilizamos um terceiro para gerar um token. Um exemplo real, é quando acessamos uma aplicação qualquer, que nos permite realizar o login com o facebook por exemplo. Logo, logamos pelo facebook, e ele nos retorna um token, dizendo: quem está logando é realmente o usuário tal. E dessa forma utilizamos nossa aplicação. O que é um <strong>token?</strong> Token é um hash de códigos ex: 789auishasfhjfa7, que nos permite identificar quem é o usuário em questão.  A diferença entre o <strong>OAUTH1 e OUATH2</strong> é que o dois possui um complemento a mais, chamado de <strong>RefreshToken</strong> que é basicamente: de tempos em tempos (ex, 5 minutos) , alterar o token.</p> 
        <p> Agora um dos mais utilizados nos dias de hoje, é através do famoso: <strong>JWT</strong>. Onde o próprio (API/BACKEND), é responsavel por gerar o token, devolver para o frontEnd, e apartir dai, em todos as requisições o front irá enviar esse token junto com a requisição, de forma que o servidor irá autorizar ou não , de acordo com o "conteúdo" dentro do token. Dito tudo isto sobre autenticação e autorização , agora podemos começar a colocar a mão no código. </p><br>
        <h2>Middlewares</h2>
        <p> Quando falamos em rotas privadas, estamos falando basicamente de rotas que só podem ser acessadas se o usuário estiver sido devidamente autenticado e autorizado como vimos acima. E uma da formas mais tradicionais de proteger essas rotas, é através do que chamamos de <strong>Middlewares</strong>. Eles são basicamente um interruptor, entre a o endpoint e o controller. Por exemplo, dentro das nossas <strong>Routes</strong> temos um endpoint: <strong>router.get('/list', controller.list)</strong>. basicamente temos a rota a ser acessada, e o método a ser executado ao acessar essa rota. Middlewares ficam localizados exatamente entre eles. Ex: /list, <strong>MIDDLEWARE</strong>, controller.list. Dessa forma, antes de mandar a requisição para o seu fluxo normal, ela será interrompida por uma espécie de porteiro, que ira verificar se o usuário está apto ou não a prosseguir, sendo a resposta positiva liberando o fluxo, sendo a resposta negativa retornadno um json com o que aconteceu. Indo para a <strong>mão no código </strong>, o primeiro passo é criarmos uma <strong>pasta Middleware</strong> na qual dentro dele iremos colocar nossos middlewares, como por exemplo o : <strong>Auth.ts</strong>. Dentro dos middlewares teremos três parâmetros: <strong>Req, Res, Next</strong> , na qual o req e o res já conhecemos, e o next significa que ele pode "seguir" o fluxo normal de funcionamento, que no nosso exemplo, é o método dentro do controller a ser executado. Mas vale deixar claro, que uma requisição para um endpoint, pode passar por quantos middlewares quisermos até chegar no seu controller e executar seu método em questão.</p>
        <img src="../backPhotos/b20.png" alt="">
 


    </div>

</body>
</html>