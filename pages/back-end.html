<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Back End.</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
        <a href="../index.html">Home</a>
        <div class="title">
            <h1>BACKEND - JS -  Resume Guide</h1>
        </div>
        <div class="nav">
            <ul>
                <li><a href="#db"> BancoDados</a></li>
                <li><a href="#pr"> Prisma</a></li>
                <li><a href="#api"> API </a></li>
                <li><a href="#mid"> Middlewares</a></li>
                <li><a href="#bsc"> Basicauth</a></li>
                <li><a href="#jwt"> JWT </a></li>
                <li><a href="#bcrypt">Bcrypt</a></li>
                <li><a href="#ema">EnvioEmail</a></li>
                <li><a href="#uimg"> UpImages/Arq</a></li>
                <li><a href="#tdd">Testes&Tdd</a></li>
            </ul>
        </div>
        <div class="nav">
            <ul>
                <li><a href="#dto"> DTO`s</a></li>
                <li><a href="#zod"> ZOD </a></li>
                <li><a href="#swagger">Swagger</a></li>
            </ul>
        </div>


    <div class="base">
        <h2 id="node"> Node JS </h2>
        <p> Aqui iremos começar a jornada do <strong>BACKEND</strong>. Indo mais direto ao ponto, de acordo com a arquitetura da programação moderna, na maioria das vezes você irá se deparar com a criação de <strong>APIS</strong>. Apis é um ponto de conexão entre o front e o banco de dados. A API é o <strong>BACKEND</strong> da sua aplicação. Por exemplo, quando voce se cadastra em um site (FrontEnd), e envia a requisição para criar nova conta, essa requisição não vai direto para o banco de dados, ela passa por um "porteiro", que irá validar os dados, confirmar com o banco se os dados já não existem , etc. Esse porteiro é a nossa API, que é o BackEnd. Dito tudo isso, praticamente sempre no mundo real o backend irá se comunicar com um banco de dados, então podemos dar início aos estudos de <strong>BackEnd</strong> através dos Banco de Dados.</p>
        <hr> 
        <h2 id="db"> MySQL </h2>
        <p> Dentro do banco de dados temos basicamente duas coisas que precisamos mexer. O Servidor( Software que é o próprio banco de dados), e o Cliente, que é o software que utiliza o servidor, ou seja, usa o bacno de dados. Por exemplo, ao desenvolvermos uma API que consome um Banco, a API é o cliente e o Banco é o servidor. Primeiramente iremos aprender sobre banco de dados <strong>Relacionais - SQL</strong>. De início começaremos com o <strong>MySQL</strong> ou o <strong>Postgree</strong>. Ambos são open source, ambos funcimam em todos os sistemas operacionais, e ambos também suportam qualquer linguagem de programação. Porém possuem algumas diferenças como o <strong>mysql</strong> NÃO ser casesenstive, já o postgree é casesensitive. Porém e quando falamos de performance? Quando falamos em querys complexas ou grandes volumes, o postgree tende a ser um pouco mais rápido, já quando falamos para pequenos volumes ou consultas simples, o mysql tende a ser mais rápido do que o postgrees. Aqui quando estamos falando de mais rápido ou mais devagar, estamos falando de diferenças de milisegundos. Dito isto, quando esta iniciando, tanto faz a escolha, sem contar que sabendo utilizar um, o outro é praticamente tão fácil quanto. </p>
        <p> O primeiro passo para começarmos a colocar a mão na massa é instalarmos o banco de dados que deseja escolher, e em seguida instalhar um <strong>cliente sql</strong> que é basicamente um software que nos permite interagir com o banco de dados em questão, executar querys, comando, etc. Particularmente eu costumo utilizar o <strong>MySQLWorkBench</strong>, que dependendo da configuração do dispositivo do usuário pode não ser a melhor escolha por acabar sendo um pouco 'pesado', porém temos opções como Dbeaver, etc.</p><br>
        <h3> ORMS </h3>
        <p> Agora que já entendemos o que são os banco de dados, seus tipos e seus clientes, precisamos entender outro fator fundamental para a integração deles com nossa aplicação(NodeJS), que são as <strong>ORMS</strong>. Existem várias formas de conectarmos os bancos de dados com nossos códigos, e uma dessas formas é o bom e velho ORM. ORM -> Object Relational Mapper, que traduzindo seria o mapeamento de um objeto-relacional. Basicamente instalamos bibliotecas em nosso sistema e criamos entre aspas uma cópia do banco de dados dentro do nosso código. Por exemplo, "O banco se chamará tal, teremos tais tabelas, cada tabela armazena tais atributos, seus tipos etc'. Mas, se já temos isso dito no banco, para que precisamos repetir no código ? Precisamos repetir no código para que ele entenda exatamente todo o comportamento do banco, desas forma, podemos dentro do código adicionar um usuário por exemplo ao banco de forma extremamente simples como : users.add(user), ao invés de termos que digitar querys longas, etc. Agora que já entendemos o que são as ORM's, estudaremos duas: <strong> Prima & Sequelize</strong>. </p><br>
        <h3 id="pr"> Prisma </h3><br>
        <p> Prisma foi feito exatamente para funcionar com o Node + Typescript. Basicamente no código criamos tudo em um só lugar. No código criamos como o banco irá ficar, que irá gerar um type, que irá criar a estrutura no banco de dados, tudo alinhado e padronizado. </p><p> O primeiro passo é criarmos nosso projeto e instalarmos a biblioteca do prisma. Para criarmos nosso projeto, poderemos utilizar um repositório que nos fornece uma pré configuração de um servidor. <a href="https://github.com/suporteb7web/node-api-base" target="_blank">NODE-API-BASE</a>. Após criado a base, precisamos instalar o Prisma em nosso projeto, com o comando: <strong>npm i -D prisma </strong>, que já vem por padrão com suporte a TypeScript. Uma das caracteristicas do Prisma é que ele trabalha com o conceito de CLI (linha de comandos no terminal).  O primeiro comando que precisamos entender é o seguinte: </p><br>
        <p> <strong>INICIAR O PRISMA: NPX PRISMA INIT </strong></p><br>
        <p> Após Criado, ele irá criar seu próprio .ENV, porém como já possuímos o nosso, basta copiar o que está la dentro, e colocar para dentro do nosso próprio env.local. Uma vez que o prisma estiver iniciado, ele já fará toda a configuração inicial, e a primeira que precisamos nos atentar, é a variavel de ambiente que copiamos. Por padrão ele vem configurado para trabalhar com POSTGREE, porém caso queiramos trocar para mysql, basta alterar ali. Ali também encontramos informacoes chave como o usuário, senha, porta e nome do banco. A única coisa que o prisma não faz é criar o próprio banco em si, isso precisaremos fazer na mão, mas o resto todo ele irá fazer por conta própria. </p>
        <p> Podemos reparar que ao instalarmos o prisma, uma pasta PRISMA foi criada, logo, o próximo passo é entendermos o que há dentro dela. Ali iremos ver que temos um <strong>schema.prisma</strong> local onde iremos realizar grande parte de nossas configurações. Vale ressaltar que tabelas no Prisma são chamadas de <strong>Model</strong>. Ali dentro teremos o <strong>generator client & datasource DB</strong>. Abaixo deles, começaremos a construir o nosso Banco.  </p>
        <img src="../backPhotos/b1.png" alt="">
        <p> O prisma possui um recurso extremamente bacana que é o <strong>PUS & PULL</strong>. Funciona mais ou menos igual no git, quando damos um git push, pegamos o código e enviamos para o repositório remoto. Quando damos um git pull, pegamos o repositório remoto e juntamos com o código. No caso do prisma ele tem o mesmo princípio. Através do <strong> push </strong> e irá enviar para o banco tudo o que configuramos em seu arquivo acima. E caso tenhamos um banco criado e queiramos pegar o banco de dados e com base nele criar um schema, podemos usar o <strong> pull </strong>. Comandos: </p><br>
        <p> <strong> ENVIAR P/ BANCO: NPX PRISMA DB PUSH</strong></p>
        <p> <strong> PUXAR DO BANCO: NPX PRISMA DB PULL </strong></p><br>
        <h3> Migrations </h3>
        <p> Esse conceito não é exclusivo do Prisma, e sim da programação em geral. São basicamente um histórico de modificação na estrutura do banco de dados. Funciona basicamente igual um Commit, criando um histórico do banco de dados. Mas para que precisamos disso ? Primeramente sempre saberemos a evolucao do banco, e também para conseguir reverter modificações. Por ex: Adicionamos um novo campo na tabela usuário, um novo campo na tabela tarefas. Caso algo de errado nessas novas features, poderemos facilmente reverter e voltar pro estado anterior. Veremos o comando das migrations: <small>Quando criamos migraitons, automaticamente ele da o Push.</small> </p><br>
        <p><strong> CRIANDO MIGRATIONS: NPX PRISMA MIGRATE DEV </strong></p><br>
        <h3> Relações/FK</h3>
        <p> Comumente dentro de nossas aplicações iremos trabalhar com entidades que possuem relações com outras entidades. Por exemplo, uma tabela de Usuários e uma tabela de Posts. Existe uma ligação entre elas, afinal, um usuário pode ter um ou muitos Posts. Para isso, basta por exemplo colocarmos dentro da tabela post, o campo UserID. Pronto, dessa forma eles passarão a ser interligados, e podemos gerenciar tudo pelo próprio código. Porém, imagine a situação em que um usuário resolve excluir sua conta. Se essa relação for feita apenas via código, iremos ter no banco de dados diversos registros de Posts de um usuário inexistente por exemplo. Por isso, é importante fazermos o relacionamento também no banco. E o Prisma nos possibilita isso, como no exemplo abaixo:  </p>
        <img src="../backPhotos/b2.png" alt="">
        <h3> Propriedades e ENUMS: </h3>
        <p> Aqui iremos dar uma visualizada nos tipos de dados e opções que temos para trabalhar dentro do Prisma. </p>
        <img src="../backPhotos/b3.png" alt="">
        <h3> Usando o MAPPING: </h3>
        <p> Mapping nao tem nenhuma aplicação prática em termos de recursos no código. Porém ele é importante no sentido de organização no código. É mais utilizado quando temos nomes diferentes entre o schema e a tabela em si do banco. Ou então quando temos por exemplo no schemna "subtitle" e no banco precisamos salvar "sub_title". Dessa forma através do <strong>mapping</strong> conseguimos realizar essas trocas. Exemplo abaixo: </p>
        <img src="../backPhotos/b4.png" alt="">
        <h3> Prisma Studio </h3>
        <p> É uma ferramenta do próprio prisma que funciona basicamente como um dbiever ou workbench, e nos apresentar através de um sistema próprio, da nossa própria estrutura do schema.prisma. Para isso precisamos digitar o comando: </p><br>
        <p> <strong> ABRIR PRISMA STUDIO: NPX PRISMA STUDIO</strong></p><br>
        <h3> Prisma Client</h3>
        <p> Como vimos anteriormente, ao darmos um prima init ele automaticamente cria um arquivo, que possui dois objetos, o de configuracao do banco, e o prisma client. E aqui iremos aprender sobre o prisma cliente, qeu será fortemente utilizado a patir de então. A partir daqui aprenderemos a utilizar o prisma no mundo real. Para isso, precisamos começar entendendo o que ele faz e como ele funciona. O <strong>prisma client</strong> nada mais é do que uma biblioteca que é criada/gerada no ato. Ela é criada conforme nosso código de configuração do Prisma. Após criarmos nossos schemas, com base nisso o prisma irá gerar para gente basicamente duas coisas distintas: Os types do Typescript exatamente igual nossos schemas. E o outro recurso, é o das relações por debaixo dos panos. Como por exemplo quando falamos user e posts, através do prisma client, podemos puxar por ex um post e as informacoes do usuário tudo de uma única vez. </p>
        <p> Dito isto, como o prisma client é gerado baseado em nosso código, sempre que alterarmos o código precisamos automáticamente gerar outro prisma client. Porém, em muitos comandos que utilizamos como por exemplo as <strong>migrations</strong> ele já atualiza o PC automáticamente. </p>
        <p> Dito isto, a partir daqui podemos definitivamente integrar o prisma ao projeto. É importante e ideal é que separemos o prisma client da aplicação. Para isso podemos criar uma pasta chamada <strong>Libs</strong> e dentro um arquivo chamado <strong>prisma.ts</strong> . Dentro desse prisma.ts , instanciaremos o prisma client, e em seguida iremos exportar essa instância, instancia essa na qual pode ser chamada de prisma ou de DB. A partir dessa instancia em qualquer lugar dentro da nossa aplicação podemos acessar o banco, através dessa instancia. Um problema muito comum de usuários de prisma é um error no banco de dados, informando que existem multiplas conexões no banco de dados, etc. Ao lermos a documentação ela explica o motivo e também a solução. É muito comum que em nossos projetos utilizemos o <strong>watch</strong>, nodemmon, etc, que nada mais é do que um recurso de monitoramento de qualquer mudança realizada na aplicação. Dessa forma, sempre que alteramos e voltamos, ele irá recarregar o código todo, logo, irá gerar uma nova instancia do prisma client, e assim uma nova conexão. Este é o <strong>Motivo do Erro</strong>, e lendo a documentação ela nos diz que precisamos copiar um trecho de código e colar em nosso prisma client. Dessa forma essa "duplicação" não irá mais acontecer. Link da documentação <a href="https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections" target="_blank">Clicando Aqui</a></p>
        <img src="../backPhotos/b5.png" alt=""><br>
        <h3> Watch & Imsonia </h3>
        <p> Antes de fato de colocarmos a mão no ORM dentro do projeto, precisamos habilitar o Watch. para isso, utilizamos o comando:  </p><br>
        <p><strong> Habilitar o Watch:  npm i -D tsx </strong></p><br>
        <p> Agora que ja temos a dependencia watch instalada, precisamos ir dentro do arquivo <strong>package.json</strong>  e alterar o "script", como o da imagem, a partir daqui, qualquer alteração que realizarmos dentro do nosso código, será monitorado e o servidor rodará novamente. </p>
        <img src="../backPhotos/b6.png" alt=""><br>
        <h3> CRUD - CREATE </h3>
        <p> Aqui iremos aprender a inserir um nobo registro na tabela. Da forma mais simples que temos, adicionamos um novo registro assim: </p>
        <img src="../backPhotos/b7.png" alt="">
        <p> <strong> OBS: </strong> Temos sempre que lembrar que a comunicação entre a API e o BANCO é uma comunicação assíncrona e do meio externo, logo, caso aconteça algum error nesse percurso, precisamos trata-los e informar aos demais. Quando falamos em tratar error, uma das primeiros coisas que lembramos é do <strong>try/catch</strong>. Abaixo um exemplo do error sendo tratado no trycatch: </p>
        <img src="../backPhotos/b8.png" alt="">
        <h2> Usando os Types do Prisma</h2>
        <p> O prisma já nos permite utilizar um type pré criados para isso. Por exemplo, podemos tipar as props de um método no service utilizando um Type fornecido pelo próprio prisma, fazendo com que a confiabilidade fique exatamente igual e de acordo com o que possuímos dentro do nosso banco de dados. Exemplo: </p>
        <img src="../backPhotos/b9.png" alt=""><br>
        <p> Outro fator muito interessante no Prisma, é que ele nos permite criar muitos usuários de uma úica vez. Por exemplo, podemos receber por parâmetro um Array de usuários, e em seguida com apenas um comando, adicionar todos os usuários de uma única vez ao banco de dados, e ainda podemos colocar um comando que nos permite pular o duplicado.</p>
        <img src="../backPhotos/b10.png" alt="">
        <hr>
        <h2 id="api"> API </h2>
        <p> Quando comecamos a estudar backend aqui no capitulo de <a href="#node">NodeJS</a> nós já demos uma pincelada sobre o que é uma API, que funciona como um intermediador entre uma aplicacao front e um banco de dados. Quando trabalhamos com WEB, usaremos constantemente os termos <strong> REST </strong> e <strong> RestFull</strong>.Rest, significa Transferencia de estado representacional, basicamente ele é um padrão. Uma api feita no padrão REST é a mesma coisa que falar: esse texto está escrito em portugues. Restfull é um sistema que utiliza um padrão Rest. Logo, se voce desenvolver uma API usando o padrão REST, ela será uma API Restfull.  O padrão REST possui alguns pilares que iremos ver nesse capítulo, como os <strong>EndPoints, Métodos(GET,POST,PUT,DEL)</strong>, entre outros que iremos ver com o tempo. </p>
        <p> Podemos começar então <strong>Criando o Projeto </strong> que pode ser criado do zero como veremos nesse módulo, ou então clonando do github nesse link já pré configurado: <a href="https://github.com/suporteb7web/node-api-base" target="_blank">NODE-API-BASE</a> que irá facilitar o processo inicial, porém é importante saber como começar do zero.</p>
        <p> Para começar do zero, precisamos gerar os seguintes comandos: <strong> npm init</strong> para startar o projeto. Em seguida, instalar as dependencias com o comando: <strong>npm install dotenv express pg pghstore sequelize validator </strong>. Para iniciar o typescript, precisamos roadr o comando: <strong>tsc --init</strong>, e em seguida realizar algumas alterações basicas como colocar para o ecmascript 6, setar a root e a outDir como na imagem abaixo, descomentar o moduleresolution: node,  e em seguida criar a pasta SRC, onde ficará concentrado todo o "core" da nossa aplicação. </p>
        <img src="../backPhotos/b11.png" alt="">
        <p> Para finalizar, precisamos instalar os Types da nossa aplicação, com o comando: <strong>npm install --save-dev @types/express @types/node @types/validator  </strong>. Tendo tudo isso configurado, podemos criar e começar a trabalhar com nosso servidor, (dentro da pasta src). </p>
        <img src="../backPhotos/b12.png" alt="">
        <p> Para finalizar a criação inicial do nosso backend, precisamos apenas criar dentro do packageJson, no objeto Scripts, o comando para startar o projeto: <strong>"start-dev": "nodemon -e ts,json src/server.ts"</strong>, e agora para startarmos basta irmos até o console e colocar: <strong>npm run start-dev</strong>.</p>
        <p> Agora que temos o "core" da nosas API criada, iremos começar a trabalhar de forma basica nela, e com o tempo separando, colocando casa coisa em seu devido "lugar". Podemos começar criando as nossas <strong>Rotas</strong>. Como já devemos imaginar, onde colocaremos nossas rotas? Exatamente, dentro de uma pasta chamada Rouets. Entao criamos essa pasta, e dentro dela podemos criar um arquivo chamado: Api.TS, onde iremos configurar nossas rotas e seus devidos Endpoints. Tendo o arquivo criado, já podemos começar a construir nossos Endpoints. De início, iremos criar o <strong>Ping/Pong</strong> que é o básico para testarmos se uma API está funcionando. Logo em seguida, precisamos colocar esse arquivo Api.ts dentro do "core" da nossa aplicação para que ele passe a ser visto. </p><br>
        <p><strong> Routes: </strong></p>
        <img src="../backPhotos/b13.png" alt="">
        <p> <strong> Implemento Routes no Core: </strong></p>
        <img src="../backPhotos/b14.png" alt="">
        <p> Muitas vezes parametros serão enviados através do Endpoint, para que possamos pegar dentro das rotas (futuramente dos controllers), para isso, podemos criar rotas dinamicas, da seguinte forma: </p>
        <img src="../backPhotos/b15.png" alt="">
        <h2> Entendendo CORS: </h2>
        <p> Quando estudamos requisições REACT no módulo de frontEnd, vimos sobre CORS, e aqui veremos mais afundo. Quando estamos criando uma API, por padrão ela só irá aceitar requisições do mesmo domínio. Logo, através das <strong>configurações do CORS</strong> podemos configurar exatamente quais domínios podem acessar nossa API, e ainda podemos ser mais específicos, podemos configurar quais métodos podem ser utilizados em cada endpoint da sua api por exemplo. Para resolver esse problema, podemos instalar uma biblioteca chamda CORS. Para isso, utilizamos o comando: <strong>npm install Cors. </strong> e também seus types: <strong>npm install -D @types/cors</strong>. Em seguida, dentro do nosso servidor, podemos importar o cors, e configugrar exatamente como gostariamos de configurar o CORS. </p>
        <img src="../backPhotos/b16.png" alt="">
        <h2> Controllers </h2>
        <p> A partir daqui passaremos a trabalhar com Controllers,entre outras páginas para que possamos separar melhor cada informação. Criamos um Controller para cada entidade da sua aplicação, e ele será o responsável por todos os métodos existentes e responsáveis por ela. Por exemplo, criaremos dentro do controller funcoes para adicionar, remover, etc. E lá nas rotas, ao invés de colocarmos a função diretamente, iremos colocar a função do Controller a ser executada. </p>
        <img src="../backPhotos/b17.png" alt="">
        <img src="../backPhotos/b18.png" alt="">
        <h2> Requisições POST: </h2>
        <p> Quando recebemos requisições post, as informacoes estão no Body (<strong>req.body)</strong></p>
        <img src="../backPhotos/b19.png" alt="">
        <h2> Status Code </h2>
        <p> Quando estamos desenvolvendo API'S padrão REST, outra coisa de fundamental importancia são os status das nossas Responses. Através desses status que os futuros consumidores de nossas API'S irão saber como lidar com os diversos tipos de respostas possíveis. Os statusCode funcionam como " números que indicam o que houve ", como por exemplo : 200 - OK, 201 - OK Adicionado, 400 - Error. etc. Você não precisa decorar exatamente cada variação, apenas a sua faixa, ex: do 0 ao 99 é isso, do 99 ao 199 aquilo, e por ai vai. </p><br>
        <h2> Autenticacao vs Autorizacao </h2>
        <p> Constantemente ao desenvolvermos aplicações iremos nos deparar com a necessidade de realizar logins, criar contas, etc. Para que isso ocorra, precisamos ter claro na mente a diferenca de Autorizacao e Autenticacao. Autorizacao, é simplesmente quando uma pessoa PODE ou NÃO pode realizar determinada tarefa. Ela não está ligada a QUEM, e sim a se pode ou não. Já a AUTENTICAÇÃO, é o processo de saber quem é o usuário que está tentando realizar tal tarefa. Na autorizacao é quando descobrimos quem é voce, e na autorizacao é se voce pode ou não realizar determinada tarefa. Agora que já entendemos a diferença entre elas, iremos nos aprofundar previamente sobre os <strong>Tipos de Autenticações</strong> que podemos vir a trabalhar. <strong>Single-Factor Auth</strong> É basicamente a de um fator, uma única etapa, ou seja, colocamos usuário e senha por exemplo, e baseado nisso o sistema lhe dá ou não o acesso. Outro tipo que vem ganhando cada vez mais espaço é a <strong>Two-Factor Authentication</strong> que é a autenticação em dois fatores, que também é conhecido como <strong>2FA</strong>, que basicamente precisamos acertar o usuário e senha, e em seguida precisamos realizar uma segunda etapa, para confirmarmos ainda mais que somos nós mesmos. Também existe o <strong>Multi-Factor Authentication (MFA) </strong>, é uma autenticacão em múltiplos fatores, onde o usuário para logar precisa enfrentar várias etapas. Outro bastante utilizado nos dias atuais e o <strong>Single Sign-On (SSO)</strong>, que seria uma "Autenticação única universal". Muito comum com sua conta do gmail por exemplo, que ao voce logar, voce automaticamente irá logar no youtube também. Ou na Meta, quando voce loga no FB, já efetua o login no Instagram também. Essas são básicamente as formas que temos de autenticar. </p>
        <p> Agora mergulheremos um pouco mais nos termos técnicos, pois independente de qual tipo de autenticação utilizar, temos um próximo passo, que é a forma de como iremos liberar o acesso após o usuario ser autenticado. E para isso existem também algumas formas que veremos aqui. <strong>Basic Auth</strong> É uma forma de em todas as requisições que tivermos dentro da aplicação iremos enviar junto o seu usuário e senha, para que possamos veririficar. Isso acontece utilizando um Hash chamado e <strong> BASE64</strong>. Apesar de já ter sido uma das formas mais utilizadas, nos dias atuais praticamente não é mais. Atualmente utilizamos as chamadas <strong> OAUTH (1 & 2)</strong>. O OAuth 1, basicamente utilizamos um terceiro para gerar um token. Um exemplo real, é quando acessamos uma aplicação qualquer, que nos permite realizar o login com o facebook por exemplo. Logo, logamos pelo facebook, e ele nos retorna um token, dizendo: quem está logando é realmente o usuário tal. E dessa forma utilizamos nossa aplicação. O que é um <strong>token?</strong> Token é um hash de códigos ex: 789auishasfhjfa7, que nos permite identificar quem é o usuário em questão.  A diferença entre o <strong>OAUTH1 e OUATH2</strong> é que o dois possui um complemento a mais, chamado de <strong>RefreshToken</strong> que é basicamente: de tempos em tempos (ex, 5 minutos) , alterar o token.</p> 
        <p> Agora um dos mais utilizados nos dias de hoje, é através do famoso: <strong>JWT</strong>. Onde o próprio (API/BACKEND), é responsavel por gerar o token, devolver para o frontEnd, e apartir dai, em todos as requisições o front irá enviar esse token junto com a requisição, de forma que o servidor irá autorizar ou não , de acordo com o "conteúdo" dentro do token. Dito tudo isto sobre autenticação e autorização , agora podemos começar a colocar a mão no código. </p><br>
        <h2 id="mid">Middlewares</h2>
        <p> Quando falamos em rotas privadas, estamos falando basicamente de rotas que só podem ser acessadas se o usuário estiver sido devidamente autenticado e autorizado como vimos acima. E uma da formas mais tradicionais de proteger essas rotas, é através do que chamamos de <strong>Middlewares</strong>. Eles são basicamente um interruptor, entre a o endpoint e o controller. Por exemplo, dentro das nossas <strong>Routes</strong> temos um endpoint: <strong>router.get('/list', controller.list)</strong>. basicamente temos a rota a ser acessada, e o método a ser executado ao acessar essa rota. Middlewares ficam localizados exatamente entre eles. Ex: /list, <strong>MIDDLEWARE</strong>, controller.list. Dessa forma, antes de mandar a requisição para o seu fluxo normal, ela será interrompida por uma espécie de porteiro, que ira verificar se o usuário está apto ou não a prosseguir, sendo a resposta positiva liberando o fluxo, sendo a resposta negativa retornadno um json com o que aconteceu. Indo para a <strong>mão no código </strong>, o primeiro passo é criarmos uma <strong>pasta Middleware</strong> na qual dentro dele iremos colocar nossos middlewares, como por exemplo o : <strong>Auth.ts</strong>. Dentro dos middlewares teremos três parâmetros: <strong>Req, Res, Next</strong> , na qual o req e o res já conhecemos, e o next significa que ele pode "seguir" o fluxo normal de funcionamento, que no nosso exemplo, é o método dentro do controller a ser executado. Mas vale deixar claro, que uma requisição para um endpoint, pode passar por quantos middlewares quisermos até chegar no seu controller e executar seu método em questão.</p>
        <img src="../backPhotos/b20.png" alt="">
        <hr>
        <h2 id="bsc"> Basic Auth </h2>
        <p> Tecnicamente o basic auth toda a requisição que fizermos também enviaremos o usuário e a senha nos Headers da requisição. Dentro dos headers, colocaremos o <strong>Authorization</strong>, com o value <strong> Basic HashBase64Encode</strong>. <small>(Testar via POSTMAN/INSOMNIA, podemos utilizar este <a href="www.base64encode.org" target="_blank"> site</a>)</small>. Ou seja, tendo esse hash (gerado no front ou via Postman), enviaremos a requisição com o seguinte Header: </p><br>
        <p><strong>header:</strong> Authorization <strong>value: </strong> Basic c7237hashafhs7824724hahas882247</p><br>
        <p> Uma vez entendido a forma que as requisições serão enviadas, todas as próximas reqs precisaremos enviar isso. Agora botando a mão no código, dentro do nosso Middleware AUTH, temos acesso a requisição, logo temos acesso ao seus Headers. O <strong>primeiro passo</strong> é verificar se esse req.headers.authorization realmente existe. Caso ele existe, partiremos para o <strong>Segundo Passo</strong> que é selecionar especificamente apenas o Hash. <small>Utilizando substring a partir da 6 posicao, afinal, basic tem 5 letras + 1 do espaço.</small>. Estando em posse do nosso hash, partimos para o <strong>terceiro passo</strong> que é o de converter o base64 para uma string normal. Em seguida, separamos o email da senha através de um 'split (':')'. Podemos aqui opcionalmente verificar se a nossa data, tenha dois registros (email e senha), para realmente conferir se está tudo perfeito. Para finalizar, vamos ao <strong>passo final</strong> que é utilizar nossa ORM e ir ao banco de dados conferir se existe um usuário com esse email e senha. Logo, caso achar, podemos continuar setando o succes para true, ou então dando o próximo next.</p>
        <img src="../backPhotos/b21.png" alt="">
        <hr>

        <h2 id="jwt"> JWT </h2>
        <p> O JSon Web Token (jwt), basicamente quando o usuário realizar o login enviando email e senha, o token é gerado dentro da API, token este que contém informações do usuário, e esse mesmo token é retornado para o usuário (front) da aplicação, de forma que ele será guardado em algum local (localSotorage, cookies), e em seguida o token automaticamente será enviado em todas as requisições para o back, onde será lido e verificado. Uma das grandes vantagens do JWT é que podemos colocar quantas e quaisquer informações que queiramos dentro do token. Outra vantagem é que o token só consegue ser decodificado através de uma chave privada que fica dentro do sistema. Logo, o usuário não consegue decodificar o token de forma alguma, pois ela só fica dentro da aplicação, e como usuários não tem acesso a aplicação, logo, fica inviolável.</p>
        <p> Para começar, precisamos instalar uma biblioteca chamada jsonwebtoken. <strong>npm i jsonwebtoken</strong>. e em seguida como ela possui suporte para typescript, precisamos instalar seus types: <strong>npm install -D @types/jsonwebtoken </strong>. A partir daqui já podemos começar a implementar.</p>
        <p> Geralmente o processo de trabalhar com JWT irá começar no momento do Login. Provavelmente teremos um método que irá receber via body dos req, um email e uma senha, e ele irá verificar através de sua ORM no banco se existem ou não existem. Caso existe retornará um ok, caso não exista retornará um false. Nesse momento que caso OK, que iremos começar a implementar o processo de login via <strong>JWT</strong>. É nesse momento que o nosso token é gerado, para isso precisamos importar o JWT from 'jsonwebtoken'. Basicamente ele possui alguns parametros. <strong>O primeiuro parametro</strong> são as informações do usuário iremos salvar dentro do token. Podemos colocar o que quisermos, como id, login, etc. O <strong>Segundo parâmetro</strong> é uma chave privada, que será responsável por criptografar e descriptografar esse token. Geralmente colocamos essa chave dentro do nosso <strong>.env</strong> ex: JWT_SECRET_KEY=QUALQUERCOISA. Podemos também colocar como terceiro parâmetor um tempo de duração desse token. Por exemplo, : {expiresIn: '2h'}. A partir daqui, temos nosso token gerado, e esse mesmo token será devolvido. </p>
        <img src="../backPhotos/b22.png" alt="">
        <p> O primeiro passo foi feito que é o de gerar o token e enviar para o usuário durante o processo de login. O próximo passo que precisaremos fazer, é o de validar se o token está ativo ou não. Vale ressaltar que caso durante a criação do seu sistema, você deseje que assim que ele se cadastrar, ele já efetuar o login automáticamente, você precisa replicar essa lógica durante o processo de Registro. Tendo isso em mente, podemos ir para a sua real validação ao decorrer das requisições. A parte de interferir, será igual vimos dentro do Basic Auth, através de <strong>middlewares</strong>. </p>
        <img src="../backPhotos/b23.png" alt="">
        <p> E dentro do nosso auth.middleware iremos realizar o processo de autenticação do JWT. O início do processo será basicamente igual o do Basic, iremos verificar se existe o <strong>req.headers.authorization</strong>. Se existir, avançamos para o próximo passo, que é pegar o seu conteúdo através de um <strong>Bearer</strong>. Por padrão esse token vem: <strong>BEARER AHSHAFSUiAFSIoHU28424</strong>, logo, precisamos dividir ele por espaço, onde no item zero teremos o tipo da auth (bearer)  e no item 1 teremos o token em questão. Em seguida, podemos verificar se o type da auth é realmente Bearer = authtype === Bearer, assim gerando mais "confiabilidade " ao nosso código. Até aqui temos verificado se existe o Header, e se o type dentro dele é Bearer, então já estamos prontos para trabalhar com o Token em si. </p>
        <p> A partir adqui validaremos o nosso token, para isso importamos o JWT e o Dotenv <small>(Para termos acesso ao secret Key)</small>. Enfim usamos o jwt.verify, que pedirá dois parâmetros, o token e a chave secreta para decodificar(Process.env.jwtsecretkey). A partir daqui já temos as informações para inspeciona-las.</p>
        <img src="../backPhotos/b24.png" alt="">
        <hr>
        <h2 id="bcrypt"> Bcrypt</h2>
        <p> Quando formos salvar a senha de um usuário no banco de dados, nós nunca iremos salvar ela direto a string pura. O ideal é que ela nem seja passada de forma pura. Para isso, utilizamos uma biblioteca chamada <strong>bcrypt</strong> para fazer a criptografia. </p>
        <img src="../backPhotos/b25.png" alt="">
        <p> E quando o usuário for tentar logar, ao receber a senha por parâmetro do REQ BODY, podemos apenas compara-la com a salva através do bcrypt compare</p>
        <img src="../backPhotos/b26.png" alt="">
        <hr>
        <h2 id="ema">Envio de Email</h2>
        <p> É muito comum quando trabalhamos com backend nos depararmos com o serviço de mensageria (envio de email), por exemplo, ao se cadastrar em um site muitas vezes você recebe algum email dizendo que se cadastrou. Ou se cadastrando em algum site voce recebe um email pedindo para confirmar o código do seu email. Para iniciarmos esse assunto, precisamos entender sobre como funciona o envio de email. A primeira coisa a saber é que o node nao tem a capacidade de enviar email, para isso, precisamos ter o auxilio de um servidor <strong>SMTP</strong>. Logo, quando enviamos email com o node, nao é ele que está realizando esse envio, ele está apenas configurando e enviando as configurações para o servidor <strong>SMTP</strong> para realizar o envio. Quando não temos um servidor SMTP, podemos utilizar um "servidor de smtp falso" para treinarmos o envio, afinal, o processo de envio será exatamente o mesmo. Para começarmos iremos instalar uma biblioteca que talvez seja a mais utilizada para essa função no universo node, a Nodemailer. <strong>Comando: npm install nodemailer</strong>, types:  <strong>Comando: npm install -D @types/nodemailer</strong>. </p>
        <p> Para enviarmos um email, realizaremos a tarefa em três passos. <strong>PASSO 01:</strong> - Configurar o Transporter. <strong>PASSO 02</strong> - Configurar a mensagem a ser enviada, <strong>PASSO 03</strong> - Enviar a mensagem. Dando início ao passo 1, o que é o <strong>transporter</strong>? É aqui onde iremos configurar o servidor smt que irá realizar o envio dessas informações. Caso tenhamos um servidor smtp a disposição, é aqui que iremos configura-lo, caso não tenhamos, poderemos utilizar um servidor de smt ('falso'), sendo um dos mais utilizados o <strong>mailtrap</strong>. Sua implementação é muito simples, pois ao se cadastrar e efetuar o login, teremos uma página com a aba <strong>SMTB SETTINGS</strong> onde selecionaremos a linguagem que iremos utilizar ( No caso node + Nodemailer), e ele já irá nos fornecer o código por completo, como mostra a imagem abaixo: </p>
        <img src="../backPhotos/b27.png" alt="">
        <p> A partir daqui, basta colarmos esse tercho de código dentro controller, ou em qualquer lugar que seja onde o usuário estará tentando enviar o email para api para ser encaminhado. Então aqui temos o <strong>PASSO 01:</strong></p>
        <img src="../backPhotos/b28.png" alt="">
        <img src="../backPhotos/b30.png" alt="">
        <p> Tendo o servidor de envio ok, poderemos ir para o segundo passo. O segundo passo como vimos, consistem em configurar a mensagem em si, com os dados enviados provavelmente através do corpo da requisição. <strong>(req.body)</strong>. Nessa configuração iremos colocar : <strong>From</strong> (quem está enviando), <strong>To</strong> - Para quem está enviando, <strong>Subject</strong> - Assunto do email, <strong>HTML</strong> - Corpo do email em si com possíveis códigos html dentro, <strong>TEXT</strong> - Corpo do email sem código html. </p>
        <img src="../backPhotos/b29.png" alt="">
        <p> Agora partimos para o terceiro e último passo, que é o de enviar a mensagem através do transporter, que é a parte mais fácil:  </p>
        <img src="../backPhotos/b31.png" alt="">
        <hr>
        <h2 id="uimg">Upload Arq/Imag</h2>







        <hr>
        <h2 id="tdd"> Testes & TDD</h2>
        <p> Para começar precisamos entender o que são e principalmente para que que nós precisamos deles. Conforme vamos construindo uma aplicação e ela vai escalando, a tendencia é que as coisas comecem a ficar de forma mais complicadas, mas em qual sentido ? Muitas vezes esquecemos como alguma coisa funciona, muitas vezes realizamos uma pequena alteração que afeta uma outra partesinha no código sem que percebamos, entre várias outras coisas. As vezes recebemos uma task para corrigir uma feature, e ao corrigir essa feature, geramos um outro error que precisará ser corrigido em breve, e por ai vai. Dito isto, testes basicamente é uma parte do código da aplicação que serve para testar se as funcionalidades estão funcionando devidamente em ordem. Por exemplo, podemos criar um teste para testar todo o funcionamento do login. Se depois de varios meses de uso, e implementçõoes novas, podemos roadar o teste do login, para saber se essas novas features não interferiram em nada o sistema de login. Essa é a definição mais abstrata do que são testes. A partir de agora iremos nos aprofundar. </p>
        <p> <Strong>TDD</Strong> - É uma sigla que significa (Test-Driven Development), desenvolvimento orientado a testes. Basicamente é um conceito que consiste em ao invés de criarmos o sistema, e depois criarmos os testes, primeiro desenhamos todos os cenários que o sistema irá funcionar, e com base nesse cenário construímos o sistema. Basicamente primeiro o teste, depois o sistema. Se em algum momento resolvermos implementar uma nova funcionalidade, primeiro desenvolvemos os testes, depois construímos baseado no teste. Vale ressaltar que o <strong>TDD</strong> não é a maneira mais ou menos correta em desenvolver uma aplicação, é apenas uma opção, e assim como tudo na programção, temos os seus prós e contras.</p>
        <img src="../backPhotos/b36.png" alt="">
        <p> A partir daqui iremos de fato entrar nos testes e passar a compreender os seus <strong>Tipos de Testes</strong>, na qual existem uma infinidade de tipos de testes. Porém a <strong>Grossíssimo </strong> modo, existem três tipos de testes: <strong>Testes Unitários, Testes de Integração, Testes E2E.</strong> </p><br>
        <p> <strong>Testes Unitários:</strong> É quando queremos testar uma parte isolada do código. Aqui não estamos falando sobre funcionalidade, e sim sobre código em si. Aqui testamos uma unidade, um item específico do sistema, seja ele uma classe, uma função, etc.  </p>
        <p> <strong>Teste de Integração:</strong> É basicamente quando estamos testando mais de uma unidade. Por exemplo, quando queremos testar se o item X e o item Y conseguem funcionar juntos. Por exemplo: Quando vamos testar o processo de Register/Login de um usuário. </p>
        <p><strong>Teste E2E</strong>: Tende a ser um pouco mais gráfico, está associado a realmente a parte visual que o usuário interpreta. Por exemplo: Se eu clicar nesse botao, esta acontecendo exatamente o que o usuário espera? Aqui tende a ser um pouco menos focado no código em si.</p><br>
        <p> Agora que já entendemos a introdução, podemos começar a entrar no código em sí. E o primeiro passo é configurarmos o nosso ambiente de testes <a href="https://alunos.b7web.com.br/curso/node/configurando-o-jest-no-seu-projeto" target="_blank">LINK</a>. Ao menos o básico. E futuramente iremos avançaremos. Quando falamos em testes no universo JS e TS, a biblioteca mais famosa e a que iremos estudar é chamda <strong>JEST</strong>. Testes geralmente não são executados em ambiente de produção (quando o site estiver no ar). Testes ficam em ambiente de desenvolvimento, para serem executados antes deles subirem. Dito isto, precisamos entender que tanto a JEST quanto seus auxiliares, instalaremos na dependencia de desenvolvimento. comando: <strong>npm install -D jest ts-jest @types/jest </strong>. A primeira coisa que faremos é criar um arquivo de configuração do JEST, onde ditaremos como os testes irão funcionar, pois existem varias forams, como por ex: rode o teste exibindo o resultado, nao exibindo, todos em paralelo, rode um para depois rodar o outro, etc. </p>
        <p> Tendo o JEST instalado, a primeira coisa que iremos fazer é rodar o comando de configinit, <strong>comando: npx ts-jest config:init</strong>, e ao realizar, observaremos que será criado um arquivo chamado <strong>jest.config.js</strong>. Eventualmente iremos realizer testes assíncronos, então para isso, começamos colocando colocando a propriedade: detectOpenHandles:True. Em seguida podemos ir até o packageJson, e alterar o <strong>script tests</strong> para configurar o comando de startar o teste. </p>
        <img src="../backPhotos/b32.png" alt="">
        <p> Tento tudo devidamente configurado, finalmente podemos começar a construir nossos testes, logo, precisamos pensar onde iremos coloca-los e para isso teremos diverssas abordagens. Basicamente o JEST procurará testes por toda a aplicação, então poderemos colocar em qualquer lugar da aplicação, porém existem determinados padrões para mantermos uma padronização. Quando falamos dos testes <strong>Unitários</strong> temos basicamente três formas de guardalos. A primeira é criar uma única pasta Test, e lá dentro organizar todos os testes da sua aplicação, (inclusive não só os unitários), porém quando a aplicação começar a escalar, isso poderá gerar dificuldade de leitura. Outra maneiro que talvez seja a mais utilizada do mercado, é por exemplo: Supomos que iremos testar o Model da entidade User. Então dentro da pasta User model onde estará o <strong>User.ts</strong> criamos um <strong>User.test.ts</strong>.Assim em cada diretório específico terá o seu arquivo e também o seu devido teste.</p>

        <p> Já para os testes de <strong>Integração</strong> criaremos uma pasta test, na qual ali dentro iremos coloca-los. Vale ressaltar que não importa onde colocaremos os testes, o JEST irá acha-lo pois ele irá percorrer toda a aplicação.</p><br>
        <h2>Criando os primeiros Teste</h2>
        <p> Vamos começar de exemplos simples, para entedermos a lógica do Teste. Aqui de início criaremos uma biblioteca para executar calculos matemáticos. Primeiro criaremos os testes, depois criaremos ela de fato. Aqui começaremos com um <strong>teste unitário</strong>. Para criarmos um teste, podemos criar uma função chamada test() ou então uma função chamada it(). Elas fazem basicamente a mesma coisa, em breve veremos alguma diferenca. Eles recebem basicamente dois parametros, o primeiro parametro e a descricao do que o teste irá executar, como por exemplo: 'Somar dois numeros corretamente', e o segundo parâmetro é a função que irá executar o teste em si. por exemplo: Math.sum(5,10). Em seguida através do <strong>expect</strong> poemos dizer o que o resultado está sendo esperado. No caso de somas matemáticas temos os exemplos:  </p>
        <img src="../backPhotos/b33.png" alt="">
        <p> Tendo criado, podemos começar a de fato testar nossos testes com o comando <strong>npm test</strong>, e assim dentro do nosso terminal ele será testado e retornará  todas as informações (quantos passaram, quantos reprovaram), quantos arquivos acharam, etc. </p>
        <p> Agora que entendemos mais ou menos como funciona a lógica, precisamos entender os tipos de matches, pois até o momento vimos apenas o <strong>to Be.</strong> No expecct colocamos a resposta , e dentro do toBe, colocamos o valor da resposta que esperamos. Porém existem diversos tipos de matches e aqui veremos alguns como o <strong>toHaveLenght</strong> que irá rodar um .lenght na string ou array. </p>
        <p> Outro cenáro é que por exemplo, supomos que queiramos no teste saber se dentro de um objeto, possui a propriedade email por exemplo podemos usar o matche <strong>toHaveProperty('name')</strong> </p>
        <img src="../backPhotos/b34.png" alt="">
        <p> Se quisermos verificar se o resultado for Undefined, podemos utilizar o match <strong>.toBeUndefined(), ou um .not.toBeUndefined()</strong>. Podemos ter também o <strong>tobeNull()</strong>, <strong>toBeGreaterThan()</strong>, <strong>toBeGreaterThanOrEqual()</strong>, <strong>toBeLessThan()</strong>, <strong>toBeLessThanOrEqual(50).</strong>. Também podemos executar REGEX dentro para ver se o toMatch(REGEXEEMAIL) por exemplo.</p><br>
        <h2>LifeCycle para Testes</h2>
        <p> Quando avançarmos nos testes por exemplo, testes com coisas que utilizam banco de dados, antes de realizarmos os testes, precisaremos criar um banco de usuário de teste, verificar sua conexão, verificações, para que assim façamos os testes. Para esses casos, temos 04 funções que irão nos auxiliar nesse processo. beforeEach, afterEach (Antes e depois de CADA teste, essas funções serão executadas. Se tivermos 20 testes, essas funcoes seãao executadas 20 vezes.) Também temos o afterall e o beforeAll, que são funções que serão executadas antes e depois de todos os testes acotnecerem. Se tivermos 20 testes, essas funções serão executadas apenas 1 vez cada. </p><br>
        <h2> Preparando ambiente Test c/ Banco</h2>
        <p> Quando estamos criando um sistema, quase sempre teremos que testar features que tenham conexão com o banco de dados. Assim como já haviamos dito, não faz muito sentido utilizarmos o nosso próprio banco de dados, ou o banco que está em produção para realizar esses testes. Para isso existem basicamente duas formas de trabalhar com esse tipo de testes. A primeira forma é criar um banco de dados específico para teste, na qual deixaremos vazio e através das <strong>migrations</strong> antes de fazermos os testes ele irá gerar nosso banco, na qual é de longe a mais utilizada. A outra maneira é a de "enganarmos" o banco de dado com um serviço como se fosse um banco de dados, porém não é. Dito isto, aqui iremos trabalhar com nosso banco de dados exclusivo para teste. O primeiro passo é informar o sistema quando que usaremos qual banco, e isso já está sendo feito através dessa linha no comando TEST dentro do packageJson. </p>
        <img src="../backPhotos/b35.png" alt="">
        <p> AQUI PRECISAMOS ESTUDAR/BUSCAR COMO CONFIGURAR COM O <STRONG>PRISMA</STRONG>. </p><br>
        <h2> Services Test </h2>
        <h2> Testando EndPoints </h2>
        <hr>
        <h2 id="dto"> DTO`S</h2>
        <p> Quando comecamos a nos aprofundar em arquitetura, etc, nos deparamos com o conceito de <strong>DTO</strong>, que sua traducao é Data Transfer Object. Basicamente é um padrao que nos exige criar uma nova classe para que possemos transferir objetos entre uma camada e outra. Muitas vezes os dados do nosso frontEnd podem ser salvos de forma diferente no Back, para isso podemos utilizar o DTO. Outro cenário muito comum é quando não queremos que o front conheça todos os campos da camada de domínio, para isso usamos o <strong>DTO</strong>. Imagine que tenhamos um backend com uma entidade extremamente robusta e no frontend precisamos exibir poucos dados dessa entidade. Nesse caso poderemos utilizar o DTO, para que possamos devolver os poucos campos que a aplicacao front irá precisar. Em resumo, a funcao do DTO é apenas de receber dados de forma "Abstrata" e de encaminha-los para algum outro lugar. (Seja do back para o front, do front para o back, ou até mesmo entre camadas do Back). É umaglomerado de dados para serem transferidos para um local onde serão efetivamente tratados. Dto é uma classe burra sem comportamento. Dentro do universo do <strong>typescript</strong> podemos utilizar os DTO'S através de <strong>Interface</strong>.</p>
        <hr>
        <h2>ZOD</h2>
        <hr>
    </div>

</body>
</html>